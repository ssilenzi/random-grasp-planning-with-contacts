function [w, r] = find_min_positive_basis_fast_robust(W, tol, th)
% find the minimal set of generators equivalent to a given set
% generators in W are passed columnwise and are assumed to be normalized
% (if not they are)
% the second return argument r is the dimension of the space generated by w
% tol (small, in [0, 1), defaults to 1e-6) is used to discard non-spanned subspaces
% i.e. those subspaces that have an associated singular value <= tol
% th (small, in [0, 1), defaults to 1e-6) is used to avoid numerical problems when
% detecting convexity

% default th
if nargin < 3
    th = 0*1e-6;
end
if (th >= 1) || (th < 0)
    th = 1e-6;
end

%default tol
if nargin < 2
    tol = 1e-6;
end
if (tol >= 1) || (tol < 0)
    tol = 1e-6;
end

% normalize W for safety
W = normalize(W,'norm');

% SVD of W to remove singleton dimension to tolerance tol
[U,S,~] = svd(W,'econ');

% align the columns of W to the principal components
W = U'*W;

% find non-singleton dimension to tolerance tol
nz = find(diag(S) > tol);
% cut out the components of W along singleton dimensions
% so to study the problem only along the non-singleton ones
WW = W(nz,:);

% the span of W up to tolerance tol is equal to the number of non-sigleton
% dimensions
r = length(nz);
if r > 1
    
    % number of input generators
    nw = size(WW,2);
    
    % add to the set of WW a set of points in the boundary of the origin
    % for convexity detection
    W0 = [-th*WW, WW];
    
    % make convex hull the point set
    p = convhulln(W0',{'Qt','Qx'});
    
    % find all the facets of the convex hull that touch at least one point
    % in the boundary of the origin
    ip0 = find(prod((p > nw),2)==0);
    
    % check the number of such facets
    if isempty(ip0)
        % if there are none, the origin is inside, so the generators can
        % generate all the space, return [I -I] for numerical stability
        ww = [eye(size(WW,1)), -eye(size(WW,1))];
    else
        % otherwise, return all the generators that are edges of the set of
        % boundary layer facets that contain also the origin
        
        % take t-uples of points defining facets of the convex hull that touch the origin
        pp = p(ip0,:);
        
        % take all the points in such t-uples and remove duplicates
        pp = unique(reshape(pp,1,numel(pp)));
        
        % take those generators in W0 that were in the orignal set WW
        % (the first half are the boundary of the origing built for robustness
        ww = W0(:,pp(pp>nw));
    end
    
else
    ww = unique(WW);
end

% re-align output vectors to the original coordinates in U
w = U*[ww; zeros(size(W,1) - r, size(ww,2))];

% normalize output for satefy
w = normalize(w,'norm');

%% non-robust, easier to understand, algorithm for reference
%
% function w = find_min_positive_basis_fast(W)
%
% % add the origin to the set of points defined by the vectors in W
% W0 = [zeros(size(W,1),1), W];
%
% % calculate convex hull of W0
% p = convhulln(W0');
%
% % find facets of the convex hull that contain the origin
% ip0 = find(prod((p-1),2) == 0);
%
% % check the number of such facets
% if isempty(ip0)
%     % if there are none, the origin is inside, so the generators can
%     % generate all the space, return [I -I] for numerical stability
%     w = [eye(size(W,1)), -eye(size(W,1))];
% else
%     % otherwise the generated set is convex, so
%
%     % take all the facets that touch the origin
%     pp = p(ip0,:);
%     % take all the (unique) points on the vertices of the facets
%     % (note: unique sorts it output in ascending order)
%     pp = unique(reshape(pp,1,numel(pp)));
%     % take all columns of W0 corresponding to those points but the first
%     % which is the origin added for calculations
%     w = W0(:,pp(2:end));
% end









